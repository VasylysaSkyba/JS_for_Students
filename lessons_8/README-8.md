Урок 8. Гра «Шибениця»

В основі гри «Шибениця» лежить принцип вгадування слів. Один гравець загадує
слово, а другий, своєю чергою, намагається його відгадати. Наприклад, якщо перший гравець
загадав слово КАПУСТА, він має зобразити сім «порожніх місць», які
відповідають буквам у слові:

_ _ _ _ _ _ _  //риски це кількість букв в слові

Другий гравець намагається відгадати це слово, називаючи різні літери. Кожен раз, коли
він відгадує букву, перший гравець заповнює порожні місця. При цьому вписуючи
названу букву скрізь, де вона трапляється. Наприклад, якщо той, хто відгадує, назвав
літеру «А», той, хто загадав слово, має вписати всі «А», які є у слові
Капуста, ось так:

_ А _ _ _ _ А

Якщо другий гравець назве букву, якої немає в слові, у нього забирається очко, а перший гравець малює поряд якусь частину тіла чоловічка. Якщо перший гравець закінчить малювати чоловічка раніше, ніж другий відгадає всі літери - другий гравець програв.

На основі правил гри «Шибениця», JavaScript вибиратиме випадкове слово, а
людина – відгадувати літери. Але малювати чоловічка програма поки що не буде.

Взаємодія з гравцем
Щоб грати в цю гру, гравцеві необхідно якимось чином вводити до програми
свої відповіді. Один із способів реалізації цієї ідеї: зробити/відкривати спеціальне діалогове вікно (prompt), у якому гравець зможе друкувати букви.

Створення діалогового вікна
Щоб створити діалогове вікно, необхідно спочатку створити html файл, потім в ньому прописати звернення до файлу, в якому буде розміщено код JavaScript.

У <head> пропишіть <script src="/path/to/script.js"></script>. 

У файл script.js введіть наступний код:

var name = prompt ("What is your name?");
console.log(“Hello, ” + name);

Потім відкрийте файл game.html у браузері.

Тут створено нову змінну name та присвоєно їй значення, яке повернуло виклик
prompt ("What is your name?"). При виклику prompt відкривається маленьке діалогове вікно (часто його називають просто діалог), показане малюнку 1:




Виклик prompt ("What is your name?") створює вікно із запитом "What is your name?" і
рядком для введення тексту. У нижній частині цього діалогу є дві кнопки - "ОК" і "Відміна".
Якщо ввести текст і натиснути «ОК», цей текст стане значенням, яке поверне до програми prompt. 
Наприклад, якщо ввести ім'я та натиснути "ОК", JavaScript надрукує його у консолі.
Оскільки введено ім'я VLAD і натиснуто "ОК", рядок "VLAD" потрапляє в змінну
name, а виклик console.log надрукував: Hello, + VLAD, тобто Hello, VLAD (рис. 1).





Якщо натиснути кнопку "Скасувати", prompt поверне значення null. null використовується для
позначення чогось, що навмисно залишено порожнім.
Після натискання «Скасувати» у консолі має з'явитися:




У цьому випадку console.log друкує null як рядок. Взагалі null не є рядком.
Згадаймо, що в консоль можна виводити лише рядки. У нашому випадку JavaScript
задано надрукувати "Hello," + null. І щоб надрукувати це значення, JavaScript
перетворив null на рядок "null".
Ситуація, коли JavaScript автоматично перетворює значення на інший тип,
називається неявним перетворенням типу.

Неявне перетворення типу – приклад того, як JavaScript намагається бути універсальним.
Спосібу об'єднати рядок і null не існує, проте JavaScript знає, що для успішного виконання операції потрібні два рядки. Рядкова версія значення null – це "null", і в результаті ми бачимо в консолі "Hello, null".



Проектування гри
Перш ніж перейти до безпосереднього проектування гри «Шибениця»,
необхідно продумати її структуру. Програма має виконувати такі дії:
1. Мимоволі вибирати слово.
2. Запитувати варіант відповіді у гравця (у нашому випадку – букву).
3. Закінчувати гру за бажанням гравця.
4. Перевірити введену відповідь (чи вона є буквою).
5. Підраховувати вгадані літери.
6. Демонструвати, які літери відгадав гравець та скільки залишилося не
відгаданими.
Завершувати гру, якщо гравець відгадав слово.


Всі ці дії, крім першого та останнього (вибір слова та завершення гри), потрібні
виконувати багаторазово. При цьому наперед невідомо, скільки разів дії мають
повторюватись (це залежить від відповідей гравця). Таким чином нескладно здогадатися, що в
програмі потрібен цикл. Однак у списку дій немає інформації, що і коли має відбуватися. Щоб з'ясувати це питання і краще уявити структуру майбутньої програми необхідно скласти блок-схему.
Блок-схема – зручний інструмент, який програмісти часто використовують при
проектування програм. 
Приклад блок-схеми: (скриншот краще замінити) !!!!!!!!!!!!!




Блок-схема дає уявлення про структуру програми, перш ніж перейти до написання
коду та з'ясування дрібних деталей.



Відображення стану гри
Одна з умов гри: показати гравцеві стан гри. Для «Шибениці» це означає, що потрібно підставити на правильні місця вгадані гравцем літери, а також показати скільки літер залишилося вгадати.
По суті, можна зберігати стан гри тим же способом, що і у звичайній «Шибениці»: у вигляді послідовності «порожніх місць», які заповнюватимуться у міру того, як гравець вгадує літери. Зробити це можна за допомогою масиву «порожніх місць» по одному елементу для кожної літери у слові. Назвати цей масив можна "result array". По-ходу гри необхідно заповнювати його вгаданими літерами. А кожне з «порожніх місць» можна подати у вигляді рядка зі знаком підкреслення: "_".

Спочатку підсумковий масив буде просто набором «порожніх місць», кількість яких
і кількості літер у загаданому слові. 
Наприклад, якщо загадано слово «риба», масив виглядатиме так:

["_", "_", "_", "_"]

Якщо гравець вгадає букву "и", замінюємо другий елемент на "и":

["_", "и", "_", "_"]

А коли гравець вгадає всі літери, масив набуде такого вигляду:

["р", "и", "б", "а"]

Також знадобиться змінна для зберігання тих літер, які потрібно вгадати. Для
кожного входження правильно вгаданої літери ця змінна зменшуватиметься на 1,
і коли вона набуде значення 0, програма зрозуміє, що гравець переміг.


Проектування ігрового циклу
Основна частина гри розташовуватиметься всередині циклу while. У циклі відображатиметься
поточний стан гри (тобто слово, спочатку представлене одними знаками підкреслення), запитувати у гравця варіант відповіді (і перевіряти, чи справді той ввів одну букву). 
А також оновлювати підсумковий масив, підставляючи введену букву, якщо вона справді присутня у слові.
Практично всі комп'ютерні ігри організовані у вигляді того чи іншого циклу, часто
структурно схожого на цикл нашої «Шибениці». Загалом ігровий цикл виконує
наступні завдання:
    Приймає введення від гравця.
    Оновлює стан гри.
    Показує гравцеві поточний стан гри.

Такого роду цикл застосовується навіть у іграх, де безперервно щось змінюється, просто цей
процес виконується дуже швидко.
У цій «Шибениці» програма запитує у гравця варіант відповіді, оновлює підсумковий масив (якщо відповідь правильна) і відображає новий стан підсумкового масиву.
Якщо гравець вгадає всі літери у слові, необхідно показати йому слово повністю, а також
вивести повідомлення з вітанням про перемогу.


Програмування гри
Тепер, коли є уявлення про структуру гри, можна переходити до написання коду.

Вибір випадкового слова
Основою гри «Шибениця» є випадкові слова. Вибрати їх можна ось так:





Мал. 1

Гра починається з рядка 1, де створюється масив зі словами (program, monkey, beautiful,
step), з якого потім вибиратиметься слово для відгадування (всі слова повинні бути
записані малими літерами). Збережіть цей масив у змінній words. У рядку 7
використовується Math.random та Math.floor, щоб вибрати з масиву випадкове слово.

Створення підсумкового масиву
Далі створіть порожній масив під назвою answerArray (підсумковий масив) та заповніть
його спеціальними символами (нижнім підкресленням) (_), кількість яких буде
відповідати кількості літер у загаданому слові (рис. 2).

У рядку 9 початку циклу for створюється змінна циклу i, яка спочатку дорівнює 0, а
потім зростає до word.length (не включаючи саме значення word.length). Під час повтору
циклу до масиву додається новий елемент — answerArray[i]. Коли цикл завершиться,
довжина answerArray буде відповідати довжині слова. Наприклад, якщо було обрано
слово «monkey» (в якому шість літер), answerArray набуде вигляду 
["_", "_", "_", "_", "_", "_"] (шість знаків підкреслення).

Нарешті, створено змінну remainingLetters, яка прирівняна до довжини загаданого слова. Ця змінна знадобиться, щоб відстежувати кількість літер, які ще треба вгадати. Щоразу, коли гравець назве правильну букву, зменшуватиметься значення цієї змінної: на один для кожного входження літери в слово.


Програмування ігрового циклу
Основа ігрового циклу виглядає так (рис. 3):





У цій програмі використовується цикл while, який повторюватиметься доти, доки умова remainingLetters > 0 дає true. У тілі циклу треба буде оновлювати remainingLetters для кожної правильної відповіді; коли гравець вгадає всі літери, remainingLetters прийме значення 0 і цикл завершиться.
Далі потрібно створити код, що становить тіло ігрового циклу.


Відображення стану гри
Гравець насамперед повинен знати поточний стан гри. У коді це можна прописати так:
alert(answerArray.join(“ ”));
Робиться це шляхом об'єднання елементів answerArray у рядок з пробілом в якості роздільника. Потім за допомогою alert показується цей рядок.

Обробка введеної відповіді
Тепер потрібно запитати у гравця відповідь і переконатися, що він ввів поодиноку літеру (мал.4).

У рядку 20 prompt запитує у гравця відповідь та зберігає її у змінній guess. Далі можливий один із чотирьох варіантів розвитку подій.
Перший варіант. Якщо гравець натисне кнопку «Скасувати», guess набере значення null. Цей варіант перевіряється у рядку 21 командою if (guess === null). Якщо ця умова дасть true, то задопомогою break можна вийти із циклу.

Другий та третій варіанти.
Гравець не ввів нічого або ввів кілька літер. Якщо він просто натиснув "ОК", нічого не вводячи, в guess виявиться порожній рядок (""). В такому випадку guess.length поверне 0. Якщо ж гравець ввів більше однієї літери, guess.length поверне число більше 1. У рядку 23 за допомогою else if (guess.length !== 1) обробляються ці варіанти, тобто відбувається перевірка, що guess містить одну літеру. В іншому випадку відображається діалог alert: «Please enter a single letter.»

Четвертий варіант. 
Гравець, як і належить, ввів одну літеру. Тоді програма повинна
оновити стан гри. Це відбувається у рядку 26, у секції else.


Оновлення стану гри
Якщо гравець ввів коректну відповідь, необхідно оновити answerArray відповідно до його відповіді. Для цього додайте в тіло else такий код, як на малюнку 5:





Мал. 5

У рядку 27 цикл for представлений змінною j. Саме вона змінюватиме значення від 0 до word.length, не включаючи саме значення word.length. У цьому циклі перевіряється кожна буква змінної слова.
У рядку 28 за допомогою if (word[j] === guess) йде перевірка, чи збігається поточна буква (word[j]) з відповіддю гравця. Якщо так, оновлюється підсумковий масив, додаючи туди букву командою answerArray[j] = guess. Для кожної літери, що збігається з відповіддю, оновлюється відповідна позиція підсумкового масиву.

Крім оновлення answerArray для кожного збігу з guess потрібно зменшувати
remainingLetters на 1. Робиться це в рядку 30 командою remainingLetters--;. Кожен раз, коли guess збігається з буквою з word, remainingLetters зменшується на 1, і коли гравець вгадає всі літери remainingLetters приймає значення 0.


Кінець гри
Ігровий цикл while виконується за умови remainingLetters > 0. Тому тіло даного циклу повторюватиметься доти, доки залишаються невідгадані літери. Коли ж remainingLetters зменшиться до 0, цикл завершиться. Після циклу залишається лише закінчити гру - це дозволяють зробити такі коди:

alert(answerArray.join(“ “));
alert(“Excellent! The word ” + word);

У першому поданому рядку востаннє відображається підсумковий масив. У другому рядку, знову ж таки за допомогою alert, 
передається вітання гравця з перемогою.


Код гри
У тексті весь код гри розібраний частинами, залишається лише з'єднати ці рядки коду. На малюнку 6 представлений весь код:



